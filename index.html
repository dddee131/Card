<!DOCTYPE html>

<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>إزالة خلفية الصورة - Canvas Method</title>
</head>
<body>
    <h1>إزالة خلفية الصورة (طريقة Canvas)</h1>

```
<div>
    <label for="imageInput">اختر صورة:</label>
    <input type="file" id="imageInput" accept="image/*">
</div>

<br>

<div>
    <label>اختر لون الخلفية المراد إزالتها:</label><br>
    <input type="radio" name="bgType" value="white" checked> أبيض
    <input type="radio" name="bgType" value="black"> أسود
    <input type="radio" name="bgType" value="green"> أخضر
    <input type="radio" name="bgType" value="blue"> أزرق
    <input type="radio" name="bgType" value="auto"> تلقائي
</div>

<br>

<div>
    <label for="tolerance">حساسية الإزالة: <span id="toleranceValue">30</span></label><br>
    <input type="range" id="tolerance" min="10" max="100" value="30">
</div>

<br>

<button id="processBtn" style="display:none;">معالجة الصورة</button>

<div id="container" style="display:none;">
    <h2>النتائج:</h2>
    <div style="display:flex; gap:20px; flex-wrap:wrap;">
        <div>
            <h3>الأصلية</h3>
            <canvas id="originalCanvas"></canvas>
        </div>
        <div>
            <h3>بعد الإزالة</h3>
            <canvas id="outputCanvas"></canvas>
        </div>
    </div>
    <br>
    <button id="downloadBtn">تحميل كـ PNG</button>
    <button id="improveBtn">تحسين النتيجة</button>
</div>

<script>
    const imageInput = document.getElementById('imageInput');
    const processBtn = document.getElementById('processBtn');
    const originalCanvas = document.getElementById('originalCanvas');
    const outputCanvas = document.getElementById('outputCanvas');
    const originalCtx = originalCanvas.getContext('2d');
    const outputCtx = outputCanvas.getContext('2d');
    const container = document.getElementById('container');
    const downloadBtn = document.getElementById('downloadBtn');
    const improveBtn = document.getElementById('improveBtn');
    const toleranceInput = document.getElementById('tolerance');
    const toleranceValue = document.getElementById('toleranceValue');
    
    let currentImage = null;

    toleranceInput.addEventListener('input', (e) => {
        toleranceValue.textContent = e.target.value;
    });

    imageInput.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    currentImage = img;
                    originalCanvas.width = img.width;
                    originalCanvas.height = img.height;
                    outputCanvas.width = img.width;
                    outputCanvas.height = img.height;
                    
                    // رسم الصورة الأصلية
                    originalCtx.drawImage(img, 0, 0);
                    
                    // إظهار زر المعالجة
                    processBtn.style.display = 'block';
                    container.style.display = 'none';
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        }
    });

    processBtn.addEventListener('click', function() {
        if (!currentImage) return;
        
        removeBackground();
        container.style.display = 'block';
    });

    improveBtn.addEventListener('click', function() {
        if (!currentImage) return;
        
        // زيادة الحساسية وإعادة المعالجة
        let currentTolerance = parseInt(toleranceInput.value);
        if (currentTolerance < 90) {
            toleranceInput.value = currentTolerance + 10;
            toleranceValue.textContent = toleranceInput.value;
            removeBackground();
        }
    });

    function removeBackground() {
        const bgType = document.querySelector('input[name="bgType"]:checked').value;
        const tolerance = parseInt(toleranceInput.value);
        
        // نسخ الصورة الأصلية
        outputCtx.drawImage(currentImage, 0, 0);
        
        // الحصول على بيانات الصورة
        const imageData = outputCtx.getImageData(0, 0, outputCanvas.width, outputCanvas.height);
        const data = imageData.data;
        
        // تحديد اللون المستهدف للإزالة
        let targetColor = getTargetColor(bgType, data, outputCanvas.width, outputCanvas.height);
        
        // معالجة كل بكسل
        for (let i = 0; i < data.length; i += 4) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            // حساب الفرق بين اللون الحالي واللون المستهدف
            const diff = Math.sqrt(
                Math.pow(r - targetColor.r, 2) +
                Math.pow(g - targetColor.g, 2) +
                Math.pow(b - targetColor.b, 2)
            );
            
            // إذا كان اللون قريب من المستهدف، اجعله شفاف
            if (diff < tolerance) {
                // حساب الشفافية بناء على القرب من اللون المستهدف
                const alpha = Math.min(255, diff * (255 / tolerance));
                data[i + 3] = alpha;
            }
        }
        
        // تطبيق التحسينات
        smoothEdges(data, outputCanvas.width, outputCanvas.height);
        
        // وضع البيانات المعدلة
        outputCtx.putImageData(imageData, 0, 0);
    }

    function getTargetColor(bgType, data, width, height) {
        switch(bgType) {
            case 'white':
                return { r: 255, g: 255, b: 255 };
            case 'black':
                return { r: 0, g: 0, b: 0 };
            case 'green':
                return { r: 0, g: 255, b: 0 };
            case 'blue':
                return { r: 0, g: 0, b: 255 };
            case 'auto':
                // حساب متوسط لون الزوايا (غالباً الخلفية)
                return calculateCornerAverage(data, width, height);
            default:
                return { r: 255, g: 255, b: 255 };
        }
    }

    function calculateCornerAverage(data, width, height) {
        const corners = [];
        const sampleSize = 10; // حجم العينة من كل زاوية
        
        // أخذ عينات من الزوايا الأربع
        for (let y = 0; y < sampleSize; y++) {
            for (let x = 0; x < sampleSize; x++) {
                // الزاوية العلوية اليسرى
                let idx = (y * width + x) * 4;
                corners.push({ r: data[idx], g: data[idx+1], b: data[idx+2] });
                
                // الزاوية العلوية اليمنى
                idx = (y * width + (width - 1 - x)) * 4;
                corners.push({ r: data[idx], g: data[idx+1], b: data[idx+2] });
                
                // الزاوية السفلى اليسرى
                idx = ((height - 1 - y) * width + x) * 4;
                corners.push({ r: data[idx], g: data[idx+1], b: data[idx+2] });
                
                // الزاوية السفلى اليمنى
                idx = ((height - 1 - y) * width + (width - 1 - x)) * 4;
                corners.push({ r: data[idx], g: data[idx+1], b: data[idx+2] });
            }
        }
        
        // حساب المتوسط
        let avgR = 0, avgG = 0, avgB = 0;
        corners.forEach(color => {
            avgR += color.r;
            avgG += color.g;
            avgB += color.b;
        });
        
        const count = corners.length;
        return {
            r: Math.round(avgR / count),
            g: Math.round(avgG / count),
            b: Math.round(avgB / count)
        };
    }

    function smoothEdges(data, width, height) {
        // تنعيم الحواف لنتيجة أفضل
        for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
                const idx = (y * width + x) * 4;
                const alpha = data[idx + 3];
                
                // إذا كان البكسل شبه شفاف
                if (alpha > 0 && alpha < 255) {
                    // حساب متوسط الشفافية من الجيران
                    let sumAlpha = 0;
                    let count = 0;
                    
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            const nIdx = ((y + dy) * width + (x + dx)) * 4;
                            sumAlpha += data[nIdx + 3];
                            count++;
                        }
                    }
                    
                    // تطبيق التنعيم
                    data[idx + 3] = Math.round(sumAlpha / count);
                }
            }
        }
    }

    downloadBtn.addEventListener('click', function() {
        const link = document.createElement('a');
        link.download = 'removed-background.png';
        link.href = outputCanvas.toDataURL('image/png');
        link.click();
    });
</script>
```

</body>
</html>